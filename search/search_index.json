{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Celery Typed Tasks provides argument serialization for complex objects using type hints . Requirements Python 3.7+ Celery 5+ Installation pip install celery-typed-tasks Example from celery import Celery from datetime import datetime import celery_typed_tasks app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , task_cls = celery_typed_tasks . TypedTask , ) @app . task () def alert ( timestamp : datetime ): if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" ) Run the application celery -A example worker --loglevel = INFO Then trigger some tasks in the REPL from datetime import datetime alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 10 )) alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 20 )) In the worker logs, you should see ... [2022-02-18 14:38:52,444: WARNING/ForkPoolWorker-8] Send a slack alert ... [2022-02-18 14:39:16,927: WARNING/ForkPoolWorker-8] I'll deal with it tomorrow ... If your next thought is I don't understand what this is doing. Isn't that what celery does? Remove the celery_typed_tasks.TypedTask from the application initialization and re-run the code. app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , ) Note Don't forget to restart your worker. Run the tasks. from datetime import datetime alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 10 )) alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 20 )) In the worker logs, you should see errors. [2022-02-18 14:45:42,265: ERROR/ForkPoolWorker-8] Task example.alert[70b5fa16-bf0a-4a36-8b08-d6b575cecc13] raised unexpected: AttributeError(\"'str' object has no attribute 'hour'\") Traceback (most recent call last): File \"/.../celery-typed-tasks-OhbqpMnr-py3.9/lib/python3.9/site-packages/celery/app/trace.py\", line 451, in trace_task R = retval = fun(*args, **kwargs) File \"/.../celery-typed-tasks-OhbqpMnr-py3.9/lib/python3.9/site-packages/celery/app/trace.py\", line 734, in __protected_call__ return self.run(*args, **kwargs) File \"/.../celery-typed-tasks/example.py\", line 79, in alert if 9 < timestamp.hour < 17: AttributeError: 'str' object has no attribute 'hour' Summary With type hints, we can have a secure, cross language solution and get complex arguments passed to our tasks. This package tries to bring run time type hinting meta programming that is becoming popular with libraries like FastAPI to Celery. With the type hints that you use with your tasks already, we can prevent some common serialization errors and build more things on top of task introspection. A note about pickle By default, celery uses json serialization for task arguments. A keen reader might say just switch to pickle! app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , ) class Config : task_serializer = \"pickle\" accept_content = [ \"pickle\" , ] app . config_from_object ( Config ) While it fixes the issue, the architecture is open to security concerns and it's limited to python producers only. With just type hints that you're already using, we can have the robust object serialization our code needs with a secure data format over the wire.","title":"Introduction"},{"location":"#introduction","text":"Celery Typed Tasks provides argument serialization for complex objects using type hints .","title":"Introduction"},{"location":"#requirements","text":"Python 3.7+ Celery 5+","title":"Requirements"},{"location":"#installation","text":"pip install celery-typed-tasks","title":"Installation"},{"location":"#example","text":"from celery import Celery from datetime import datetime import celery_typed_tasks app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , task_cls = celery_typed_tasks . TypedTask , ) @app . task () def alert ( timestamp : datetime ): if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" ) Run the application celery -A example worker --loglevel = INFO Then trigger some tasks in the REPL from datetime import datetime alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 10 )) alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 20 )) In the worker logs, you should see ... [2022-02-18 14:38:52,444: WARNING/ForkPoolWorker-8] Send a slack alert ... [2022-02-18 14:39:16,927: WARNING/ForkPoolWorker-8] I'll deal with it tomorrow ... If your next thought is I don't understand what this is doing. Isn't that what celery does? Remove the celery_typed_tasks.TypedTask from the application initialization and re-run the code. app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , ) Note Don't forget to restart your worker. Run the tasks. from datetime import datetime alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 10 )) alert . delay ( timestamp = datetime ( year = 2022 , month = 1 , day = 1 , hour = 20 )) In the worker logs, you should see errors. [2022-02-18 14:45:42,265: ERROR/ForkPoolWorker-8] Task example.alert[70b5fa16-bf0a-4a36-8b08-d6b575cecc13] raised unexpected: AttributeError(\"'str' object has no attribute 'hour'\") Traceback (most recent call last): File \"/.../celery-typed-tasks-OhbqpMnr-py3.9/lib/python3.9/site-packages/celery/app/trace.py\", line 451, in trace_task R = retval = fun(*args, **kwargs) File \"/.../celery-typed-tasks-OhbqpMnr-py3.9/lib/python3.9/site-packages/celery/app/trace.py\", line 734, in __protected_call__ return self.run(*args, **kwargs) File \"/.../celery-typed-tasks/example.py\", line 79, in alert if 9 < timestamp.hour < 17: AttributeError: 'str' object has no attribute 'hour'","title":"Example"},{"location":"#summary","text":"With type hints, we can have a secure, cross language solution and get complex arguments passed to our tasks. This package tries to bring run time type hinting meta programming that is becoming popular with libraries like FastAPI to Celery. With the type hints that you use with your tasks already, we can prevent some common serialization errors and build more things on top of task introspection.","title":"Summary"},{"location":"#a-note-about-pickle","text":"By default, celery uses json serialization for task arguments. A keen reader might say just switch to pickle! app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , ) class Config : task_serializer = \"pickle\" accept_content = [ \"pickle\" , ] app . config_from_object ( Config ) While it fixes the issue, the architecture is open to security concerns and it's limited to python producers only. With just type hints that you're already using, we can have the robust object serialization our code needs with a secure data format over the wire.","title":"A note about pickle"},{"location":"example/","text":"Example FastAPI Continuing off the example in the FastAPI documentation, we can generate an api for tasks with custom task serialization and a little meta programming. import typing from inspect import signature import pydantic from celery import Celery from fastapi import FastAPI from pydantic import BaseModel import celery_typed_tasks class TypedTask ( celery_typed_tasks . TypedTask ): def dump_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , pydantic . BaseModel ): return obj . dict () return super () . dump_obj ( obj , annotation ) def load_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , pydantic . BaseModel ): return annotation ( ** obj ) return super () . load_obj ( obj , annotation ) celery_app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , task_cls = TypedTask , ) class Item ( BaseModel ): name : str description : typing . Optional [ str ] = None price : float tax : typing . Optional [ float ] = None @celery_app . task () def create_item ( item : Item ): return item fast_api_app = FastAPI () def register_task_views ( celery_app , fast_api_app ): for task_name , task in celery_app . tasks . items (): # Only create api endpoints for tasks defined in the celery_app skip built in celery tasks if task_name . startswith ( \"celery\" ): continue # The view must be defined in a closure. Otherwise `task` will be passed by reference during the iteration. def view_factory ( task ): def task_view ( * args , ** kwargs ): task . delay ( * args , ** kwargs ) return task_view view = view_factory ( task ) # The view acts as proxy but we can copy the signature so fast api can automagically work. view . __signature__ = signature ( task . run ) fast_api_app . post ( f \"/tasks/ { task_name } \" )( view ) register_task_views ( celery_app , fast_api_app )","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#fastapi","text":"Continuing off the example in the FastAPI documentation, we can generate an api for tasks with custom task serialization and a little meta programming. import typing from inspect import signature import pydantic from celery import Celery from fastapi import FastAPI from pydantic import BaseModel import celery_typed_tasks class TypedTask ( celery_typed_tasks . TypedTask ): def dump_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , pydantic . BaseModel ): return obj . dict () return super () . dump_obj ( obj , annotation ) def load_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , pydantic . BaseModel ): return annotation ( ** obj ) return super () . load_obj ( obj , annotation ) celery_app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , task_cls = TypedTask , ) class Item ( BaseModel ): name : str description : typing . Optional [ str ] = None price : float tax : typing . Optional [ float ] = None @celery_app . task () def create_item ( item : Item ): return item fast_api_app = FastAPI () def register_task_views ( celery_app , fast_api_app ): for task_name , task in celery_app . tasks . items (): # Only create api endpoints for tasks defined in the celery_app skip built in celery tasks if task_name . startswith ( \"celery\" ): continue # The view must be defined in a closure. Otherwise `task` will be passed by reference during the iteration. def view_factory ( task ): def task_view ( * args , ** kwargs ): task . delay ( * args , ** kwargs ) return task_view view = view_factory ( task ) # The view acts as proxy but we can copy the signature so fast api can automagically work. view . __signature__ = signature ( task . run ) fast_api_app . post ( f \"/tasks/ { task_name } \" )( view ) register_task_views ( celery_app , fast_api_app )","title":"FastAPI"},{"location":"usage/","text":"Usage TypedTask Celery App Initialization To use celery typed tasks for all tasks in your application, initialize your Celery app with the celery_typed_task.TypedTask task class. from celery import Celery import celery_typed_tasks app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , task_cls = celery_typed_tasks . TypedTask , ) @app . task () def alert ( timestamp : datetime ): if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" ) Disable type hint serialization If you need to disable serialization for an individual task, type_hint_serialization=False will skip any custom serialization. @app . task ( type_hint_serialization = False ) def alert ( timestamp : datetime | str ): if timestamp is str : timestamp = datetime . fromisoformat ( timestamp ) if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" ) Task with TypedTask base If you prefer to not set the TypedTask as the base task for the entire application, celery allows customization on a per task basis. from celery import Celery import celery_typed_tasks app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , ) @app . task ( base = celery_typed_task . TypedTask ) def alert ( timestamp : datetime ): if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" ) Argument Types Standard Library Types celery_typed_tasks supports the following standard library types: bool int float str dict set list dataclass Decimal datetime date time uuid None Generic Types celery_typed_tasks supports some generic types. list[T] set[T] Serialization Custom object dump and load To serialize out custom objects, you can use the dump_obj and load_obj methods on the task. import celery_typed_tasks import typing class File : url : str def __init__ ( self , url ): self . url = url class MyTypedTask ( celery_typed_tasks . TypedTask ): def dump_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , File ): return obj . url return super () . dump_obj ( obj , annotation ) def load_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , File ): return annotation ( obj ) return super () . load_obj ( obj , annotation ) Celery Configuration task_type_hint_serialization Default False If you need to disable type hint serialization globally for an application that is using TypedTasks , you can set the task_type_hint_serialization config setting.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#typedtask","text":"","title":"TypedTask"},{"location":"usage/#celery-app-initialization","text":"To use celery typed tasks for all tasks in your application, initialize your Celery app with the celery_typed_task.TypedTask task class. from celery import Celery import celery_typed_tasks app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , task_cls = celery_typed_tasks . TypedTask , ) @app . task () def alert ( timestamp : datetime ): if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" )","title":"Celery App Initialization"},{"location":"usage/#disable-type-hint-serialization","text":"If you need to disable serialization for an individual task, type_hint_serialization=False will skip any custom serialization. @app . task ( type_hint_serialization = False ) def alert ( timestamp : datetime | str ): if timestamp is str : timestamp = datetime . fromisoformat ( timestamp ) if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" )","title":"Disable type hint serialization"},{"location":"usage/#task-with-typedtask-base","text":"If you prefer to not set the TypedTask as the base task for the entire application, celery allows customization on a per task basis. from celery import Celery import celery_typed_tasks app = Celery ( \"example\" , broker = \"pyamqp://guest@localhost//\" , ) @app . task ( base = celery_typed_task . TypedTask ) def alert ( timestamp : datetime ): if 9 < timestamp . hour < 17 : print ( \"Send a slack alert\" ) else : print ( \"I'll deal with it tomorrow\" )","title":"Task with TypedTask base"},{"location":"usage/#argument-types","text":"","title":"Argument Types"},{"location":"usage/#standard-library-types","text":"celery_typed_tasks supports the following standard library types: bool int float str dict set list dataclass Decimal datetime date time uuid None","title":"Standard Library Types"},{"location":"usage/#generic-types","text":"celery_typed_tasks supports some generic types. list[T] set[T]","title":"Generic Types"},{"location":"usage/#serialization","text":"","title":"Serialization"},{"location":"usage/#custom-object-dump-and-load","text":"To serialize out custom objects, you can use the dump_obj and load_obj methods on the task. import celery_typed_tasks import typing class File : url : str def __init__ ( self , url ): self . url = url class MyTypedTask ( celery_typed_tasks . TypedTask ): def dump_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , File ): return obj . url return super () . dump_obj ( obj , annotation ) def load_obj ( self , obj : typing . Any , annotation : typing . Any ) -> typing . Any : if issubclass ( annotation , File ): return annotation ( obj ) return super () . load_obj ( obj , annotation )","title":"Custom object dump and load"},{"location":"usage/#celery-configuration","text":"","title":"Celery Configuration"},{"location":"usage/#task_type_hint_serialization","text":"Default False If you need to disable type hint serialization globally for an application that is using TypedTasks , you can set the task_type_hint_serialization config setting.","title":"task_type_hint_serialization"}]}